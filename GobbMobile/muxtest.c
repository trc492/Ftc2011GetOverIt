#pragma config(Sensor, S4,     HTSMUX,              sensorI2CCustom)
#pragma config(Motor,  motorA,          motorRight,    tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          motorLeft,     tmotorNormal, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#if 0
/// Copyright (c) Michael Tsang. All rights reserved.
///
/// <module name="IRTest.c" />
///
/// <summary>
///     This module contains the main code.
/// </summary>
///
/// <remarks>
///     Environment: RobotC for Lego Mindstorms NXT.
/// </remarks>
#endif

#include "joystickdriver.c"
#include "../HTDriversV1.6/drivers/common.h"
#include "..\trclib\trcdefs.h"
#include "..\trclib\dbgtrace.h"
#include "..\trclib\batt.h"
#include "..\trclib\sensor.h"

#ifdef MOD_ID
    #undef MOD_ID
#endif
#define MOD_ID                  MOD_MAIN

//
// Trace info.
//
#define TRACE_MODULES           (MOD_MAIN)
#define TRACE_LEVEL             TASK
#define MSG_LEVEL               INFO

#define THRESHOLD_LO_LIGHT      180
#define THRESHOLD_HI_LIGHT      450

//
// Global data.
//
BATT    g_Batt;
SENSOR  g_LeftLight;
SENSOR  g_CenterLight;
SENSOR  g_RightLight;

/**
 *  This function handles the sensor notification events.
 *
 *  @param sensor Points to the SESNOR structure that generated the event.
 */
void
SensorEvent(
    __in SENSOR &sensor
    )
{
    TFuncName("SensorEvent");
    TLevel(EVENT);
    TEnterMsg(("Sensor=%d,Zone=%d", sensor.sensorID, sensor.sensorZone));

    switch (sensor.sensorID)
    {
        case msensor_S4_1:
            nxtDisplayTextLine(3, "lZone=%d", sensor.sensorZone);
            break;

        case msensor_S4_2:
            nxtDisplayTextLine(4, "cZone=%d", sensor.sensorZone);
            break;

        case msensor_S4_3:
            nxtDisplayTextLine(5, "rZone=%d", sensor.sensorZone);
            break;

        default:
            break;
    }

    TExit();
    return;
}   //SensorEvent

/**
 *  This function initializes the robot and its subsystems.
 */
void
RobotInit()
{
    TFuncName("RobotInit");
    TLevel(INIT);
    TEnter();

    BattInit(g_Batt, 7, false);
    //
    // Initialize all sensors.
    //
    HTSMUXinit();
    HTSMUXscanPorts(HTSMUX);

    HTSMUXsetAnalogueActive(msensor_S4_1);
    HTSMUXsetAnalogueActive(msensor_S4_2);
    HTSMUXsetAnalogueActive(msensor_S4_3);

    SensorInit(g_LeftLight,
               msensor_S4_1,
               THRESHOLD_LO_LIGHT,
               THRESHOLD_HI_LIGHT,
               SENSORF_HTSMUX | SENSORF_ENABLE_EVENTS);
    SensorInit(g_CenterLight,
               msensor_S4_2,
               THRESHOLD_LO_LIGHT,
               THRESHOLD_HI_LIGHT,
               SENSORF_HTSMUX | SENSORF_ENABLE_EVENTS);
    SensorInit(g_RightLight,
               msensor_S4_3,
               THRESHOLD_LO_LIGHT,
               THRESHOLD_HI_LIGHT,
               SENSORF_HTSMUX | SENSORF_ENABLE_EVENTS);

    TExit();
    return;
}   //RobotInit

/**
 *  This function processes all the high frequency tasks that needs to run
 *  more often than other tasks such as sensor integration tasks.
 */
void
HiFreqTasks()
{
    TFuncName("HiFreqTasks");
    TLevel(TASK);
    TEnter();


    TExit();
    return;
}   //HiFreqTasks

/**
 *  This function processes all the input tasks.
 */
void
InputTasks()
{
    TFuncName("InputTasks");
    TLevel(TASK);
    TEnter();

    SensorTask(g_LeftLight);
    SensorTask(g_CenterLight);
    SensorTask(g_RightLight);
    nxtDisplayTextLine(1, "L=%d,C=%d",
                       g_LeftLight.sensorValue,
                       g_CenterLight.sensorValue);
    nxtDisplayTextLine(2, "R=%d",
                       g_RightLight.sensorValue);

    TExit();
    return;
}   //InputTasks

/**
 *  This function processes all the main tasks.
 */
void
MainTasks()
{
    TFuncName("MainTasks");
    TLevel(TASK);
    TEnter();



    TExit();
    return;
}   //MainTasks

/**
 *  This function processes all the output tasks. Output tasks are where all
 *  the actions are taking place. All other tasks are just changing states of
 *  various objects. There is no action taken until the output tasks.
 */
void
OutputTasks()
{
    TFuncName("OutputTasks");
    TLevel(TASK);
    TEnter();

    BattTask(g_Batt);

    TExit();
    return;
}   //OutputTasks

/**
 *  This task is the program entry point.
 */
task main()
{
    long nextTime;
    long currTime;

    TraceInit(TRACE_MODULES, TRACE_LEVEL, MSG_LEVEL);

    RobotInit();

    nextTime = nPgmTime;
    while (true)
    {
        TPeriodStart();
        currTime = nPgmTime;
        HiFreqTasks();
        if (currTime >= nextTime)
        {
            nextTime = currTime + LOOP_TIME;

            InputTasks();
            MainTasks();
            OutputTasks();
        }
        TPeriodEnd();

        wait1Msec(1);
    }
}   //main
