#pragma config(Sensor, S1,     lightRight,          sensorLightActive)
#pragma config(Sensor, S2,     lightCenter,         sensorLightActive)
#pragma config(Sensor, S3,     sonar,               sensorSONAR)
#pragma config(Sensor, S4,     lightLeft,           sensorLightActive)
#pragma config(Motor,  motorA,          motorRight,    tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          motorGrabber,  tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          motorLeft,     tmotorNormal, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#if 0
/// Copyright (c) Michael Tsang. All rights reserved.
///
/// <module name="GobbMobile.c" />
///
/// <summary>
///     This module contains the main code.
/// </summary>
///
/// <remarks>
///     Environment: RobotC for Lego Mindstorms NXT.
/// </remarks>
#endif

#define _DEBUG_TRACE

#include "JoystickDriver.c"
#include "..\trclib\trcdefs.h"
#include "..\trclib\dbgtrace.h"
#include "..\trclib\batt.h"
#include "..\trclib\menu.h"
#include "..\trclib\nxtbtn.h"
#include "..\trclib\joybtn.h"
#include "..\trclib\sensor.h"
#include "..\trclib\sm.h"
#include "..\trclib\pidctrl.h"
#include "..\trclib\drive.h"
DRIVE   g_Drive[1];
PIDCTRL g_PIDCtrl[3];
#include "..\trclib\piddrive.h"
#include "..\trclib\lnfollow.h"
#include "GobbInfo.h"
#include "grabber.h"

#ifdef MOD_ID
    #undef MOD_ID
#endif
#define MOD_ID                  MOD_MAIN

//
// Trace info.
//
#define TRACE_MODULES           (MOD_MAIN)
#define TRACE_LEVEL             TASK
#define MSG_LEVEL               INFO

#define EVTTYPE_PIDDRIVE        (EVTTYPE_NONE + 1)

//
// Autonomous modes.
//
#define AUTOMODE_DISABLED       0
#define AUTOMODE_LNFOLLOW       1
#define AUTOMODE_JAIL           2

//
// Global data.
//
BATT     g_Batt;
MENU     g_Menu;
NXTBTN   g_NxtBtn;
JOYBTN   g_JoyBtn;
SENSOR   g_Sonar;
//DRIVE    g_Drive;
//PIDCTRL  g_DrivePIDCtrl;
//PIDCTRL  g_TurnPIDCtrl;
PIDDRIVE g_PIDDrive;
//PIDCTRL  g_LnFollowPIDCtrl;
LNFOLLOW g_LnFollow;
GRABBER  g_Grabber;
SM       g_LnFollowSM;
SM       g_JailSM;
int      g_AutoMode = AUTOMODE_DISABLED;
bool     g_fCalDrive = false;
bool     g_fObstacleAhead = false;
bool     g_fDarkZone = false;

/**
 *  This function displays the menu and performs the action chosen.
 */
void
RunMenu(
    __in MENU &menu
    )
{
    int action;
    TFuncName("MenuRun");
    TLevel(FUNC);
    TEnter();

    action = MenuGetChoice(menu);
    eraseDisplay();

    switch (action)
    {
        case 1:
            PIDDriveSetTarget(g_PIDDrive,
                              96.0, ENCODER_DRIVE_TOLERANCE,
                              0.0, ENCODER_TURN_TOLERANCE,
                              true);
            g_fCalDrive = true;
            nxtDisplayTextLine(2, "Forward 8 ft");
            break;

        case 2:
            PIDDriveSetTarget(g_PIDDrive,
                              -96.0, ENCODER_DRIVE_TOLERANCE,
                              0.0, ENCODER_TURN_TOLERANCE,
                              true);
            g_fCalDrive = true;
            nxtDisplayTextLine(2, "Backward 8 ft");
            break;

        case 3:
            PIDDriveSetTarget(g_PIDDrive,
                              0.0, ENCODER_DRIVE_TOLERANCE,
                              360.0, ENCODER_TURN_TOLERANCE,
                              true);
            g_fCalDrive = true;
            nxtDisplayTextLine(2, "Turn 360");
            break;
    }

    TExit();
    return;
}   //RunMenu

/**
 *  This function handles the NXT button events.
 *
 *  @param nxtbtn Points to the NXTBTN structure.
 *  @param nxtButton Specifies the button that generated the event.
 *  @param fPressed If true, the button was pressed, otherwise it was
 *         released.
 */
void
NxtBtnEvent(
    __in NXTBTN &nxtbtn,
    __in int nxtButton,
    __in bool fPressed
    )
{
    TFuncName("NxtBtnEvent");
    TLevel(EVENT);
    TEnterMsg(("Button=%d,On=%d", nxtButton, (byte)fPressed));

    switch (nxtButton)
    {
        case kEnterButton:
            if (fPressed && (g_AutoMode == AUTOMODE_DISABLED))
            {
                RunMenu(g_Menu);
            }
            break;

        case kExitButton:
            break;

        case kLeftButton:
            break;

        case kRightButton:
            break;
    }

    TExit();
    return;
}   //NxtBtnEvent

/**
 *  This function handles the joystick button notification events.
 *
 *  @param joybtn Points to the JOYBTN structure that generated the event.
 */
void
JoyBtnEvent(
    __in JOYBTN &joybtn
    )
{
    TFuncName("JoyBtnEvent");
    TLevel(EVENT);
    TEnterMsg(("Button=%x,On=%d", joybtn.buttonMask, (byte)joybtn.fPressed));

    if (joybtn.joystickID == 1)
    {
        switch (joybtn.buttonMask)
        {
	        case Xbox_A:
	            if (joybtn.fPressed)
	            {
	                if (IsSMDisabled(g_LnFollowSM))
	                {
	                    SMStop(g_JailSM);
	                    SMStart(g_LnFollowSM);
	                    g_AutoMode = AUTOMODE_LNFOLLOW;
	                }
	                else
	                {
	                    LnFollowStart(g_LnFollow, false);
	                    SMStop(g_LnFollowSM);
	                    g_AutoMode = AUTOMODE_DISABLED;
	                }
	            }
	            break;

	        case Xbox_B:
	            if (joybtn.fPressed)
	            {
	                if (IsSMDisabled(g_JailSM))
	                {
	                    SMStop(g_LnFollowSM);
	                    SMStart(g_JailSM);
	                    g_AutoMode = AUTOMODE_JAIL;
	                }
	                else
	                {
	                    SMStop(g_JailSM);
	                    g_AutoMode = AUTOMODE_DISABLED;
	                }
	            }
	            break;

	        case Xbox_X:
	            if (joybtn.fPressed)
	            {
	                GrabberStartCal(g_Grabber);
	            }
	            break;

            case Xbox_Y:
	            if ((g_AutoMode == AUTOMODE_DISABLED) && joybtn.fPressed)
                {
                    //
                    // We only do calibration in teleop mode.
                    // When calibrating the light sensors for the Line
                    // Follower, start calibration mode and drive the robot
                    // around to sample the brightest white and the darkest
                    // black on the floor. Then stop the calibration so that
                    // it can compute the low and high thresholds for each
                    // light sensor.
                    //
                    if (LnFollowCalibrating(g_LnFollow))
                    {
                        //
                        // We were in calibration mode, we are done.
                        //
                        LnFollowCal(g_LnFollow, false);
                        nxtDisplayTextLine(2, "LnFollowCal=off");
#if 0
                        nxtDisplayTextLine(3, "LLo=%d,LHi=%d",
                                           g_LeftLight.lowThreshold,
                                           g_LeftLight.highThreshold);
                        nxtDisplayTextLine(4, "CLo=%d,CHi=%d",
                                           g_CenterLight.lowThreshold,
                                           g_CenterLight.highThreshold);
                        nxtDisplayTextLine(5, "RLo=%d,RHi=%d",
                                           g_RightLight.lowThreshold,
                                           g_RightLight.highThreshold);
#endif
                    }
                    else
                    {
                        //
                        // We weren't in calibration mode, start it.
                        //
                        LnFollowCal(g_LnFollow, true);
                        nxtDisplayTextLine(2, "LnFollowCal=on");
                    }
                }
                break;

            case Xbox_LB:
	            if ((g_AutoMode == AUTOMODE_DISABLED) && joybtn.fPressed)
                {
                    //
                    // We only do calibration in teleop mode.
                    // Do a PID distance calibration, drive forward 8 ft.
                    //
                    if (g_fCalDrive)
                    {
                        g_fCalDrive = false;
                    }
                    else
                    {
                        PIDDriveSetTarget(g_PIDDrive,
                                          96.0, ENCODER_DRIVE_TOLERANCE,
                                          0.0, ENCODER_TURN_TOLERANCE,
                                          true);
                        g_fCalDrive = true;
                    }
                }
                break;

            case Xbox_RB:
	            if ((g_AutoMode == AUTOMODE_DISABLED) && joybtn.fPressed)
                {
                    //
                    // We only do calibration in teleop mode.
                    // Do a PID angle calibration, turn clockwise 360 degrees.
                    //
                    if (g_fCalDrive)
                    {
                        g_fCalDrive = false;
                    }
                    else
                    {
                        PIDDriveSetTarget(g_PIDDrive,
                                          0.0, ENCODER_DRIVE_TOLERANCE,
                                          360.0, ENCODER_TURN_TOLERANCE,
                                          true);
                        g_fCalDrive = true;
                    }
                }
                break;

            default:
	            break;
  	    }
    }

	TExit();
    return;
}   //JoyBtnEvent

/**
 *  This function handles the sensor notification events.
 *
 *  @param sensor Points to the SESNOR structure that generated the event.
 */
void
SensorEvent(
    __in SENSOR &sensor
    )
{
    TFuncName("SensorEvent");
    TLevel(EVENT);
    TEnterMsg(("Sensor=%d,Zone=%d", sensor.sensorID, sensor.sensorZone));

    switch (sensor.sensorID)
    {
        case lightLeft:
        case lightRight:
            break;

        case lightCenter:
            g_fDarkZone = sensor.sensorZone == SENSORZONE_LO;
            break;

        case sonar:
            g_fObstacleAhead = sensor.sensorZone == SENSORZONE_LO;
            break;

        default:
            break;
    }

    TExit();
    return;
}   //SensorEvent

/**
 *  This function provides the input value for various PID controllers.
 *
 *  @param pidCtrlID Specifies the PID Controller ID.
 *
 *  @return Returns the input value for the PID controller.
 */
float
PIDCtrlGetInput(
    __in int pidCtrlID
    )
{
    float inputValue = 0.0;

    TFuncName("PIDCtrlGetInput");
    TLevel(CALLBK);
    TEnter();

    switch (pidCtrlID)
    {
        case 0:
            inputValue = (float)(nMotorEncoder[motorLeft] +
                                 nMotorEncoder[motorRight])*
                         DISTANCE_PER_CLICK/2.0;
            break;

        case 1:
            inputValue = (float)(nMotorEncoder[motorLeft] -
                                 nMotorEncoder[motorRight])*
                         DEGREES_PER_CLICK;
            break;

        case 2:
            inputValue = (float)g_LnFollow.sensorValue;
            break;
    }

    TExitMsg(("=%5.1f", inputValue));
    return inputValue;
}   //PIDCtrlGetInput

/**
 *  This function handles the drive notification events.
 *
 *  @param drive Points to the DRIVE structure that generated the event.
 */
void
PIDDriveEvent(
    __in PIDDRIVE &pidDrive
    )
{
    TFuncName("PIDDriveEvent");
    TLevel(EVENT);
    TEnter();

    if (g_AutoMode == AUTOMODE_LNFOLLOW)
    {
        //
        // In line following mode.
        //
        SMSetEvent(g_LnFollowSM, EVTTYPE_PIDDRIVE, 0, 0, 0, 0);
    }
    else if (g_AutoMode == AUTOMODE_JAIL)
    {
        //
        // In jail mode.
        //
        SMSetEvent(g_JailSM, EVTTYPE_PIDDRIVE, 0, 0, 0, 0);
    }
    else if (g_fCalDrive)
    {
        g_fCalDrive = false;
    }

    TExit();
    return;
}   //PIDDriveEvent

/**
 *  This function implements the state machine for line follow mode.
 *
 *  @param sm Points to the SM structure.
 */
void
LnFollowSM(
    __inout SM &smLnFollow
    )
{
    TFuncName("LnFollowSM");
    TLevel(TASK);
    TEnter();

    if (SMIsReady(smLnFollow))
    {
        //
        // We only execute the autonomous state machine if it is not in wait
        // mode.
        //
        switch (smLnFollow.currState)
        {
            case SMSTATE_STARTED:
                nxtDisplayTextLine(2, "wtSensor=%d",
                                   g_LnFollow.sensorValue);
                if (g_LnFollow.sensorValue == 0)
                {
                    //
                    // Don't see the line, drive forward full speed.
                    //
                    DriveArcade(g_Drive[0], 50, 0);
                }
                else
                {
                    //
                    // Found the line, follow it.
                    //
                    LnFollowStart(g_LnFollow, true);
                    smLnFollow.currState++;
                }
                break;

            case SMSTATE_STARTED + 1:
                LnFollowTask(g_LnFollow);
                break;

            default:
                break;
        }
    }

    TExit();
    return;
}   //LnFollowSM

/**
 *  This function implements the state machine for jail mode.
 *
 *  @param sm Points to the SM structure.
 */
void
JailSM(
    __inout SM &smJail
    )
{
    TFuncName("JailSM");
    TLevel(TASK);
    TEnter();

    if (SMIsReady(smJail))
    {
        //
        // We only execute the autonomous state machine if it is not in wait
        // mode.
        //
        if ((DEADBAND_INPUT(joystick.joy1_y1) != 0) ||
            (DEADBAND_INPUT(joystick.joy1_x1) != 0))
        {
	        int powerDrive = NORMALIZE_DRIVE(DEADBAND_INPUT(joystick.joy1_y1),
	                                         -128, 127);
	        int powerTurn = NORMALIZE_DRIVE(DEADBAND_INPUT(joystick.joy1_x1),
	                                        -128, 127);
            //
            // The user is overriding autonomous.
            //
//            DriveArcade(g_Drive, powerDrive, powerTurn);
            DriveArcade(g_Drive[0], powerDrive, powerTurn);
            smJail.currState = SMSTATE_STARTED;
        }
        else
        {
            static int obstacleDist = 0;
            static int turnPower = -30;

            switch (smJail.currState)
            {
                case SMSTATE_STARTED:
                    //
                    // State: Seek Jail
                    //
                    if (g_fObstacleAhead)
                    {
                        //
                        // Obstacle ahead, turn to avoid it.
                        //
                        obstacleDist = SensorValue(sonar);
                        smJail.currState = SMSTATE_STARTED + 1;
                    }
                    else if (g_fDarkZone)
                    {
                        //
                        // Entering Jail.
                        //
                        smJail.currState = SMSTATE_STARTED + 2;
                    }
                    else
                    {
                        //
                        // Keep seeking.
                        //
//                        DriveArcade(g_Drive, 50, 0);
                        DriveArcade(g_Drive[0], 50, 0);
                    }
                    break;

                case SMSTATE_STARTED + 1:
                    //
                    // State: Obstacle
                    //
                    if (!g_fObstacleAhead)
                    {
                        //
                        // Go back to seek state.
                        //
                        smJail.currState = SMSTATE_STARTED;
                    }
                    else
                    {
                        if (obstacleDist - SensorValue(sonar) > 5)
                        {
                            //
                            // Wrong direction, turn the other way.
                            //
                            turnPower *= -1;
                        }
//                        DriveArcade(g_Drive, 30, turnPower);
                        DriveArcade(g_Drive[0], 30, turnPower);
                    }
                    break;

                case SMSTATE_STARTED + 2:
                    //
                    // State: In Jail
                    //
                    if (g_fObstacleAhead)
                    {
                        //
                        // Obstacle ahead, turn to avoid it.
                        //
                        obstacleDist = SensorValue(sonar);
                        smJail.currState = SMSTATE_STARTED + 1;
                    }
                    else if (g_fDarkZone)
                    {
                        //
                        // Keep going inside the jail.
                        //
//                        DriveArcade(g_Drive, 50, 0);
                        DriveArcade(g_Drive[0], 50, 0);
                    }
                    else
                    {
                        //
                        // Reached jail boundaray, back up.
                        //
                        smJail.currState = SMSTATE_STARTED + 3;
                    }
                    break;

                case SMSTATE_STARTED + 3:
                    //
                    // State: Backup
                    //
                    if (g_fDarkZone)
                    {
                        PIDDriveSetTarget(g_PIDDrive,
                                          20.0, ENCODER_DRIVE_TOLERANCE,
                                          20.0, ENCODER_TURN_TOLERANCE,
                                          true);
                        SMAddWaitEvent(smJail, EVTTYPE_PIDDRIVE, -1, -1);
                        SMWaitEvents(smJail,
                                     SMSTATE_STARTED + 2,
                                     0,
                                     SMF_CLEAR_EVENTS);
                    }
                    else
                    {
                        //
                        // Backup.
                        //
//                        DriveArcade(g_Drive, -20, 0);
                        DriveArcade(g_Drive[0], -20, 0);
                    }
                    break;

                default:
                    break;
            }
        }
    }

    TExit();
    return;
}   //JailSM

/**
 *  This function initializes the robot and its subsystems.
 */
void
RobotInit()
{
    TFuncName("RobotInit");
    TLevel(INIT);
    TEnter();

    BattInit(g_Batt, 7, false);
    //
    // Init choice menu.
    //
    MenuInit(g_Menu, "Routines:", 0, 0);
    MenuAddChoice(g_Menu, "TeleOp");
    MenuAddChoice(g_Menu, "Forward 8 ft");
    MenuAddChoice(g_Menu, "Backward 8 ft");
    MenuAddChoice(g_Menu, "Turn 360");

    NxtBtnInit(g_NxtBtn, NXTBTNF_ENABLE_EVENTS);

    //
    // Initialize joystick buttons.
    //
    JoyBtnInit(g_JoyBtn, 1, JOYBTNF_ENABLE_EVENTS);

    //
    // Initialize all sensors.
    //
    SensorInit(g_LnFollow.LightSensors[0],
               lightLeft,
               THRESHOLD_LO_LIGHT,
               THRESHOLD_HI_LIGHT,
               SENSORF_INVERSE);
    SensorInit(g_LnFollow.LightSensors[1],
               lightCenter,
               THRESHOLD_LO_LIGHT,
               THRESHOLD_HI_LIGHT,
               SENSORF_INVERSE);
    SensorInit(g_LnFollow.LightSensors[2],
               lightRight,
               THRESHOLD_LO_LIGHT,
               THRESHOLD_HI_LIGHT,
               SENSORF_INVERSE);
    SensorInit(g_Sonar,
               sonar,
               THRESHOLD_LO_SONAR,
               THRESHOLD_HI_SONAR,
               0);

    //
    // Initialize the PID Drive subsystem.
    //
//    DriveInit(g_Drive,
    DriveInit(g_Drive[0],
              motorLeft,
              motorRight,
              DISTANCE_PER_CLICK,
              DEGREES_PER_CLICK);
//    PIDCtrlInit(g_DrivePIDCtrl,
    PIDCtrlInit(g_PIDCtrl[0], 0,
                ENCODER_DRIVE_KP, ENCODER_DRIVE_KI, ENCODER_DRIVE_KD,
                MOTOR_MIN_VALUE, MOTOR_MAX_VALUE,
                0);
//    PIDCtrlInit(g_TurnPIDCtrl,
    PIDCtrlInit(g_PIDCtrl[1], 1,
                ENCODER_TURN_KP, ENCODER_TURN_KI, ENCODER_TURN_KD,
                MOTOR_MIN_VALUE, MOTOR_MAX_VALUE,
                0);
    PIDDriveInit(g_PIDDrive,
                 0, //Drive,
                 0, //DrivePIDCtrl,
                 1, //TurnPIDCtrl,
                 PIDDRIVEF_ENABLE_EVENTS);

    //
    // Initialize the Line Follower subsystem.
    //
//    PIDCtrlInit(g_LnFollowPIDCtrl,
    PIDCtrlInit(g_PIDCtrl[2], 2,
                LNFOLLOW_TURN_KP, LNFOLLOW_TURN_KI, LNFOLLOW_TURN_KD,
                MOTOR_MIN_VALUE, MOTOR_MAX_VALUE,
                PIDCTRLF_ABS_SETPOINT);
    LnFollowInit(g_LnFollow,
//                 g_Drive,
                 0,
//                 g_LnFollowPIDCtrl,
                 2,
                 MAX_LIGHT_SENSORS,
                 LNFOLLOW_DRIVE_KP);

    //
    // Initialize the Grabber subsystem.
    //
    GrabberInit(g_Grabber,
                motorGrabber,
                GRABBER_CAL_POWER,
                GRABBER_MAX_POWER,
                GRABBER_MIN_POS,
                GRABBER_MAX_POS,
                GRABBER_TIME_STEP);

    //
    // Initialize state machines.
    //
    SMInit(g_LnFollowSM);
    SMInit(g_JailSM);

    TExit();
    return;
}   //RobotInit

/**
 *  This function processes all the high frequency tasks that needs to run
 *  more often than other tasks such as sensor integration tasks.
 */
void
HiFreqTasks()
{
    TFuncName("HiFreqTasks");
    TLevel(TASK);
    TEnter();

    TExit();
    return;
}   //HiFreqTasks

/**
 *  This function processes all the input tasks.
 */
void
InputTasks()
{
    TFuncName("InputTasks");
    TLevel(TASK);
    TEnter();

    NxtBtnTask(g_NxtBtn);
    getJoystickSettings(joystick);
    JoyBtnTask(g_JoyBtn);
    SensorTask(g_Sonar);
    SensorTask(g_LnFollow.LightSensors[0]);
    SensorTask(g_LnFollow.LightSensors[1]);
    SensorTask(g_LnFollow.LightSensors[2]);

    TExit();
    return;
}   //InputTasks

/**
 *  This function processes all the main tasks.
 */
void
MainTasks()
{
    TFuncName("MainTasks");
    TLevel(TASK);
    TEnter();

//    nxtDisplayTextLine(3, "Left  : %d", SensorValue[lightLeft]);
//    nxtDisplayTextLine(4, "Center: %d", SensorValue[lightCenter]);
//    nxtDisplayTextLine(5, "Right : %d", SensorValue[lightRight]);
    if (g_AutoMode == AUTOMODE_LNFOLLOW)
    {
        //
        // Line following mode.
        //
        nxtDisplayTextLine(0, "Mode=LF,State=%d",
                           g_LnFollowSM.currState);
        LnFollowSM(g_LnFollowSM);
    }
    else if (g_AutoMode == AUTOMODE_JAIL)
    {
        //
        // Jail mode.
        //
        nxtDisplayTextLine(0, "Mode=Jail,State=%d",
                           g_JailSM.currState);
        JailSM(g_JailSM);
    }
    else if (!g_fCalDrive)
    {
        int powerDrive = NORMALIZE_DRIVE(DEADBAND_INPUT(joystick.joy1_y1),
                                         -128, 127);
        int powerTurn = NORMALIZE_DRIVE(DEADBAND_INPUT(joystick.joy1_x1),
                                        -128, 127);
        //
        // TeleOp mode.
        //
        nxtDisplayTextLine(0, "Mode=TeleOp");
        nxtDisplayTextLine(1, "D=%d,T=%d", powerDrive, powerTurn);
//        DriveArcade(g_Drive, powerDrive, powerTurn);
        DriveArcade(g_Drive[0], powerDrive, powerTurn);
    }

    int powerGrabber = NORMALIZE(joystick.joy1_x2, -128, 127,
                                 -GRABBER_MAX_POWER, GRABBER_MAX_POWER);

    GrabberSetPower(g_Grabber, powerGrabber);

    TExit();
    return;
}   //MainTasks

/**
 *  This function processes all the output tasks. Output tasks are where all
 *  the actions are taking place. All other tasks are just changing states of
 *  various objects. There is no action taken until the output tasks.
 */
void
OutputTasks()
{
    TFuncName("OutputTasks");
    TLevel(TASK);
    TEnter();

    PIDDriveTask(g_PIDDrive);
//    DriveTask(g_Drive);
    DriveTask(g_Drive[0]);
    GrabberTask(g_Grabber);
    BattTask(g_Batt);

    TExit();
    return;
}   //OutputTasks

/**
 *  This task is the program entry point.
 */
task main()
{
    long nextTime;
    long currTime;

    TraceInit(TRACE_MODULES, TRACE_LEVEL, MSG_LEVEL);
    TFuncName("main");

    RobotInit();

    nextTime = nPgmTime;
    while (true)
    {
        TPeriodStart();
        currTime = nPgmTime;
        HiFreqTasks();
        if (currTime >= nextTime)
        {
            nextTime = currTime + LOOP_TIME;

            InputTasks();
            MainTasks();
            OutputTasks();

            TInfo(("LoopTime=%d,Curr=%d", nPgmTime - currTime, currTime));
        }
        TPeriodEnd();

        wait1Msec(1);
    }
}   //main
